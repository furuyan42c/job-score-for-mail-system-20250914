-- ============================================================================
-- バイト求人マッチングシステム スコアリング関数
-- Version: 1.1.0
-- Database: PostgreSQL 15 (Supabase)
-- Created: 2025-09-18
-- ============================================================================

-- ============================================================================
-- SECTION 1: ヘルパー関数
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 1.1 地理的距離計算（Haversine formula）
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_distance_km(
    lat1 DECIMAL(10,8),
    lon1 DECIMAL(11,8),
    lat2 DECIMAL(10,8),
    lon2 DECIMAL(11,8)
) RETURNS FLOAT AS $$
DECLARE
    R CONSTANT FLOAT := 6371; -- 地球の半径（km）
    dlat FLOAT;
    dlon FLOAT;
    a FLOAT;
    c FLOAT;
BEGIN
    IF lat1 IS NULL OR lon1 IS NULL OR lat2 IS NULL OR lon2 IS NULL THEN
        RETURN NULL;
    END IF;

    dlat := radians(lat2 - lat1);
    dlon := radians(lon2 - lon1);

    a := sin(dlat/2) * sin(dlat/2) +
         cos(radians(lat1)) * cos(radians(lat2)) *
         sin(dlon/2) * sin(dlon/2);

    c := 2 * atan2(sqrt(a), sqrt(1-a));

    RETURN R * c;
END;
$$ LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE;

-- ----------------------------------------------------------------------------
-- 1.2 エリア別平均給与計算
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_area_salary_stats(
    p_pref_cd CHAR(2),
    p_city_cd VARCHAR(5) DEFAULT NULL
) RETURNS TABLE (
    avg_salary FLOAT,
    std_dev FLOAT,
    min_salary FLOAT,
    max_salary FLOAT,
    sample_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT
        AVG(CASE
            WHEN salary_type = 'hourly' THEN min_salary::FLOAT
            WHEN salary_type = 'daily' THEN min_salary::FLOAT / 8  -- 8時間換算
            ELSE min_salary::FLOAT / 160  -- 月給を時給換算（160時間/月）
        END) as avg_salary,
        STDDEV(CASE
            WHEN salary_type = 'hourly' THEN min_salary::FLOAT
            WHEN salary_type = 'daily' THEN min_salary::FLOAT / 8
            ELSE min_salary::FLOAT / 160
        END) as std_dev,
        MIN(CASE
            WHEN salary_type = 'hourly' THEN min_salary::FLOAT
            WHEN salary_type = 'daily' THEN min_salary::FLOAT / 8
            ELSE min_salary::FLOAT / 160
        END) as min_salary,
        MAX(CASE
            WHEN salary_type = 'hourly' THEN min_salary::FLOAT
            WHEN salary_type = 'daily' THEN min_salary::FLOAT / 8
            ELSE min_salary::FLOAT / 160
        END) as max_salary,
        COUNT(*)::INTEGER as sample_count
    FROM jobs
    WHERE is_active = TRUE
      AND pref_cd = p_pref_cd
      AND (p_city_cd IS NULL OR city_cd = p_city_cd)
      AND min_salary IS NOT NULL
      AND min_salary > 0;
END;
$$ LANGUAGE plpgsql STABLE PARALLEL SAFE;

-- ============================================================================
-- SECTION 2: 基礎スコア計算
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 2.1 時給スコア正規化（Z-score）
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION normalize_hourly_wage_score(
    p_job_id BIGINT
) RETURNS FLOAT AS $$
DECLARE
    v_job RECORD;
    v_stats RECORD;
    v_hourly_wage FLOAT;
    v_z_score FLOAT;
    v_normalized_score FLOAT;
BEGIN
    -- 求人情報取得
    SELECT
        min_salary,
        salary_type,
        pref_cd,
        city_cd
    INTO v_job
    FROM jobs
    WHERE job_id = p_job_id;

    IF NOT FOUND OR v_job.min_salary IS NULL THEN
        RETURN 50.0;  -- デフォルト中央値
    END IF;

    -- 時給換算
    v_hourly_wage := CASE v_job.salary_type
        WHEN 'hourly' THEN v_job.min_salary
        WHEN 'daily' THEN v_job.min_salary / 8.0
        ELSE v_job.min_salary / 160.0
    END;

    -- エリア統計取得
    SELECT * INTO v_stats
    FROM calculate_area_salary_stats(v_job.pref_cd, v_job.city_cd);

    IF v_stats.std_dev IS NULL OR v_stats.std_dev = 0 THEN
        RETURN 50.0;
    END IF;

    -- Z-score計算
    v_z_score := (v_hourly_wage - v_stats.avg_salary) / v_stats.std_dev;

    -- 0-100スケールに正規化（±3σを0-100にマッピング）
    v_normalized_score := 50 + (v_z_score * 16.67);

    RETURN GREATEST(0, LEAST(100, v_normalized_score));
END;
$$ LANGUAGE plpgsql STABLE;

-- ----------------------------------------------------------------------------
-- 2.2 報酬（fee）スコア計算
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION normalize_fee_score(
    p_fee INTEGER
) RETURNS FLOAT AS $$
BEGIN
    IF p_fee IS NULL OR p_fee <= 500 THEN
        RETURN 0.0;  -- 500円以下は0点
    ELSIF p_fee >= 5000 THEN
        RETURN 100.0;  -- 5000円以上は満点
    ELSE
        -- 500-5000円の範囲で線形スケール
        RETURN ((p_fee - 500)::FLOAT / 4500.0) * 100.0;
    END IF;
END;
$$ LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE;

-- ----------------------------------------------------------------------------
-- 2.3 企業人気度スコア計算
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_company_popularity_score(
    p_endcl_cd VARCHAR(20)
) RETURNS FLOAT AS $$
DECLARE
    v_popularity_score FLOAT;
BEGIN
    SELECT popularity_score
    INTO v_popularity_score
    FROM company_popularity
    WHERE endcl_cd = p_endcl_cd;

    IF NOT FOUND OR v_popularity_score IS NULL THEN
        RETURN 30.0;  -- デフォルト低めのスコア
    END IF;

    RETURN v_popularity_score;
END;
$$ LANGUAGE plpgsql STABLE;

-- ----------------------------------------------------------------------------
-- 2.4 アクセス利便性スコア
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_access_convenience_score(
    p_job_id BIGINT,
    p_user_id INTEGER DEFAULT NULL
) RETURNS FLOAT AS $$
DECLARE
    v_job RECORD;
    v_user RECORD;
    v_distance FLOAT;
    v_station_score FLOAT := 0;
    v_distance_score FLOAT := 50;
BEGIN
    -- 求人情報取得
    SELECT
        latitude, longitude,
        station_name_eki,
        pref_cd, city_cd
    INTO v_job
    FROM jobs
    WHERE job_id = p_job_id;

    -- 駅近ボーナス
    IF v_job.station_name_eki IS NOT NULL THEN
        v_station_score := 20;
    END IF;

    -- ユーザーとの距離計算（オプション）
    IF p_user_id IS NOT NULL THEN
        SELECT
            cm.latitude,
            cm.longitude
        INTO v_user
        FROM users u
        LEFT JOIN city_master cm ON u.estimated_city_cd = cm.code
        WHERE u.user_id = p_user_id;

        IF v_user.latitude IS NOT NULL AND v_job.latitude IS NOT NULL THEN
            v_distance := calculate_distance_km(
                v_user.latitude, v_user.longitude,
                v_job.latitude, v_job.longitude
            );

            -- 距離によるスコア（10km以内は満点、50km以上は0点）
            v_distance_score := CASE
                WHEN v_distance <= 10 THEN 100
                WHEN v_distance >= 50 THEN 0
                ELSE 100 - ((v_distance - 10) * 2.5)
            END;
        END IF;
    END IF;

    RETURN LEAST(100, v_station_score + (v_distance_score * 0.8));
END;
$$ LANGUAGE plpgsql STABLE;

-- ----------------------------------------------------------------------------
-- 2.5 基礎スコア統合関数
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_basic_score(
    p_job_id BIGINT,
    p_user_id INTEGER DEFAULT NULL
) RETURNS FLOAT AS $$
DECLARE
    v_job RECORD;
    v_wage_score FLOAT;
    v_fee_score FLOAT;
    v_popularity_score FLOAT;
    v_access_score FLOAT;
    v_final_score FLOAT;
BEGIN
    -- 求人基本情報取得
    SELECT
        job_id,
        fee,
        endcl_cd
    INTO v_job
    FROM jobs
    WHERE job_id = p_job_id;

    IF NOT FOUND THEN
        RETURN 0.0;
    END IF;

    -- 各コンポーネントスコア計算
    v_wage_score := normalize_hourly_wage_score(p_job_id);
    v_fee_score := normalize_fee_score(v_job.fee);
    v_popularity_score := calculate_company_popularity_score(v_job.endcl_cd);
    v_access_score := calculate_access_convenience_score(p_job_id, p_user_id);

    -- 重み付け合計（仕様書準拠）
    -- 時給: 40%, fee: 30%, 人気度: 30%
    v_final_score := (v_wage_score * 0.4) +
                     (v_fee_score * 0.3) +
                     (v_popularity_score * 0.3);

    -- アクセススコアはボーナス（最大10点）
    IF p_user_id IS NOT NULL THEN
        v_final_score := v_final_score + (v_access_score * 0.1);
    END IF;

    RETURN GREATEST(0, LEAST(100, v_final_score));
END;
$$ LANGUAGE plpgsql STABLE;

-- ============================================================================
-- SECTION 3: SEOスコア計算
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 3.1 キーワードマッチングスコア
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_keyword_match_score(
    p_text TEXT,
    p_keyword VARCHAR(100)
) RETURNS FLOAT AS $$
DECLARE
    v_match_count INTEGER;
    v_text_length INTEGER;
    v_keyword_length INTEGER;
    v_density FLOAT;
    v_score FLOAT;
BEGIN
    IF p_text IS NULL OR p_keyword IS NULL THEN
        RETURN 0.0;
    END IF;

    -- テキストを小文字化して検索
    v_text_length := length(lower(p_text));
    v_keyword_length := length(p_keyword);

    -- キーワード出現回数
    v_match_count := (
        SELECT COUNT(*)
        FROM regexp_split_to_table(lower(p_text), '\s+') as word
        WHERE word LIKE '%' || lower(p_keyword) || '%'
    );

    IF v_match_count = 0 THEN
        RETURN 0.0;
    END IF;

    -- キーワード密度計算
    v_density := (v_match_count::FLOAT * v_keyword_length) / v_text_length * 100;

    -- 密度に基づくスコア（2-8%が理想的）
    v_score := CASE
        WHEN v_density < 2 THEN v_density * 25  -- 低すぎる
        WHEN v_density BETWEEN 2 AND 8 THEN 50 + ((v_density - 2) * 8.33)  -- 理想的
        ELSE 100 - ((v_density - 8) * 5)  -- 高すぎる（キーワードスタッフィング）
    END;

    RETURN GREATEST(0, LEAST(100, v_score));
END;
$$ LANGUAGE plpgsql IMMUTABLE PARALLEL SAFE;

-- ----------------------------------------------------------------------------
-- 3.2 SEOスコア統合関数
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_seo_score(
    p_job_id BIGINT
) RETURNS FLOAT AS $$
DECLARE
    v_job RECORD;
    v_keyword RECORD;
    v_total_score FLOAT := 0;
    v_match_count INTEGER := 0;
    v_title_score FLOAT;
    v_desc_score FLOAT;
    v_keyword_score FLOAT;
    v_search_volume_weight FLOAT;
BEGIN
    -- 求人情報取得
    SELECT
        application_name,
        description,
        benefits,
        search_keywords
    INTO v_job
    FROM jobs
    WHERE job_id = p_job_id;

    IF NOT FOUND THEN
        RETURN 0.0;
    END IF;

    -- SEOキーワードとマッチング
    FOR v_keyword IN
        SELECT
            sk.keyword,
            sk.search_volume,
            sk.difficulty
        FROM semrush_keywords sk
        WHERE sk.search_volume > 100  -- 最小検索ボリューム
        ORDER BY sk.search_volume DESC
        LIMIT 50  -- パフォーマンスのため上位50個
    LOOP
        -- タイトルマッチング（重要度高）
        v_title_score := calculate_keyword_match_score(
            v_job.application_name,
            v_keyword.keyword
        );

        -- 説明文マッチング
        v_desc_score := calculate_keyword_match_score(
            COALESCE(v_job.description, '') || ' ' || COALESCE(v_job.benefits, ''),
            v_keyword.keyword
        );

        -- 検索ボリュームによる重み付け
        v_search_volume_weight := LEAST(1.0, v_keyword.search_volume::FLOAT / 10000);

        -- キーワードスコア計算
        v_keyword_score := (
            (v_title_score * 0.6 + v_desc_score * 0.4) *
            v_search_volume_weight
        );

        IF v_keyword_score > 0 THEN
            v_total_score := v_total_score + v_keyword_score;
            v_match_count := v_match_count + 1;

            -- 求人-キーワード関連を記録
            INSERT INTO job_keywords (job_id, keyword_id, match_count)
            SELECT p_job_id, sk.keyword_id, 1
            FROM semrush_keywords sk
            WHERE sk.keyword = v_keyword.keyword
            ON CONFLICT (job_id, keyword_id)
            DO UPDATE SET match_count = job_keywords.match_count + 1;
        END IF;
    END LOOP;

    -- 平均スコア計算
    IF v_match_count > 0 THEN
        RETURN LEAST(100, (v_total_score / v_match_count) * 1.5);
    ELSE
        RETURN 10.0;  -- マッチなしでも最小スコア
    END IF;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- ============================================================================
-- SECTION 4: パーソナライズドスコア計算
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 4.1 ユーザー嗜好スコア
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_user_preference_score(
    p_job_id BIGINT,
    p_user_id INTEGER
) RETURNS FLOAT AS $$
DECLARE
    v_job RECORD;
    v_user RECORD;
    v_profile RECORD;
    v_score FLOAT := 0;
    v_category_match FLOAT := 0;
    v_salary_match FLOAT := 0;
    v_feature_match FLOAT := 0;
BEGIN
    -- 求人情報取得
    SELECT
        occupation_cd1,
        min_salary,
        salary_type,
        feature_codes
    INTO v_job
    FROM jobs
    WHERE job_id = p_job_id;

    -- ユーザー情報取得
    SELECT
        preferred_categories,
        preferred_salary_min,
        preferred_work_styles
    INTO v_user
    FROM users
    WHERE user_id = p_user_id;

    -- ユーザープロファイル取得
    SELECT
        category_interests,
        preference_scores
    INTO v_profile
    FROM user_profiles
    WHERE user_id = p_user_id;

    IF NOT FOUND THEN
        RETURN 50.0;  -- プロファイルなしはデフォルト
    END IF;

    -- カテゴリマッチング
    IF v_job.occupation_cd1 = ANY(v_user.preferred_categories) THEN
        v_category_match := 100;
    ELSIF v_profile.category_interests IS NOT NULL THEN
        v_category_match := COALESCE(
            (v_profile.category_interests->>(v_job.occupation_cd1::TEXT))::FLOAT * 100,
            30
        );
    END IF;

    -- 給与マッチング
    IF v_user.preferred_salary_min IS NOT NULL AND v_job.min_salary IS NOT NULL THEN
        IF v_job.min_salary >= v_user.preferred_salary_min THEN
            v_salary_match := 100;
        ELSE
            v_salary_match := (v_job.min_salary::FLOAT / v_user.preferred_salary_min) * 100;
        END IF;
    ELSE
        v_salary_match := 50;
    END IF;

    -- 特徴マッチング
    IF v_user.preferred_work_styles IS NOT NULL AND
       array_length(v_user.preferred_work_styles, 1) > 0 THEN
        v_feature_match := (
            SELECT COUNT(*)::FLOAT * 20
            FROM unnest(v_user.preferred_work_styles) AS style
            WHERE EXISTS (
                SELECT 1 FROM unnest(v_job.feature_codes) AS fc
                WHERE fc LIKE style || '%'
            )
        );
    END IF;

    -- 総合スコア計算
    v_score := (v_category_match * 0.4) +
               (v_salary_match * 0.3) +
               (v_feature_match * 0.3);

    RETURN GREATEST(0, LEAST(100, v_score));
END;
$$ LANGUAGE plpgsql STABLE;

-- ----------------------------------------------------------------------------
-- 4.2 協調フィルタリングスコア
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_collaborative_filtering_score(
    p_job_id BIGINT,
    p_user_id INTEGER
) RETURNS FLOAT AS $$
DECLARE
    v_user_factors FLOAT[];
    v_similar_users INTEGER[];
    v_similarity_score FLOAT;
    v_engagement_score FLOAT;
BEGIN
    -- ユーザーの潜在因子取得
    SELECT latent_factors
    INTO v_user_factors
    FROM user_profiles
    WHERE user_id = p_user_id;

    IF v_user_factors IS NULL OR array_length(v_user_factors, 1) = 0 THEN
        -- 潜在因子なしの場合は行動ベースの簡易スコア
        SELECT
            COUNT(DISTINCT ua.user_id)::FLOAT * 10
        INTO v_engagement_score
        FROM user_actions ua
        WHERE ua.job_id = p_job_id
          AND ua.action_type IN ('click', 'application')
          AND ua.user_id IN (
              -- 類似ユーザーの簡易判定
              SELECT DISTINCT ua2.user_id
              FROM user_actions ua1
              JOIN user_actions ua2 ON ua1.job_id = ua2.job_id
              WHERE ua1.user_id = p_user_id
                AND ua2.user_id != p_user_id
              LIMIT 100
          );

        RETURN LEAST(100, COALESCE(v_engagement_score, 30));
    END IF;

    -- 類似ユーザーの行動から予測（本来はimplicit ALSの結果を使用）
    WITH similar_users AS (
        SELECT
            up.user_id,
            1 - (
                -- コサイン類似度の簡易計算
                SELECT SUM(
                    (v_user_factors[i] - up.latent_factors[i])^2
                )::FLOAT / 50  -- 50次元
                FROM generate_series(1, 50) AS i
            ) AS similarity
        FROM user_profiles up
        WHERE up.user_id != p_user_id
          AND up.latent_factors IS NOT NULL
        ORDER BY similarity DESC
        LIMIT 50
    )
    SELECT
        AVG(CASE
            WHEN ua.action_type = 'application' THEN 100
            WHEN ua.action_type = 'click' THEN 50
            ELSE 20
        END * su.similarity)
    INTO v_similarity_score
    FROM similar_users su
    JOIN user_actions ua ON su.user_id = ua.user_id
    WHERE ua.job_id = p_job_id;

    RETURN COALESCE(v_similarity_score, 40);
END;
$$ LANGUAGE plpgsql STABLE;

-- ----------------------------------------------------------------------------
-- 4.3 地域近接性スコア
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_location_proximity_score(
    p_job_id BIGINT,
    p_user_id INTEGER
) RETURNS FLOAT AS $$
DECLARE
    v_job RECORD;
    v_user RECORD;
    v_distance FLOAT;
    v_user_radius INTEGER;
    v_score FLOAT;
BEGIN
    -- 求人の位置情報
    SELECT
        j.pref_cd,
        j.city_cd,
        j.latitude,
        j.longitude,
        cm.latitude AS city_lat,
        cm.longitude AS city_lon
    INTO v_job
    FROM jobs j
    LEFT JOIN city_master cm ON j.city_cd = cm.code
    WHERE j.job_id = p_job_id;

    -- ユーザーの位置情報と設定
    SELECT
        u.estimated_pref_cd,
        u.estimated_city_cd,
        up.location_preference_radius,
        cm.latitude,
        cm.longitude
    INTO v_user
    FROM users u
    LEFT JOIN user_profiles up ON u.user_id = up.user_id
    LEFT JOIN city_master cm ON u.estimated_city_cd = cm.code
    WHERE u.user_id = p_user_id;

    -- 同じ都道府県ボーナス
    IF v_job.pref_cd = v_user.estimated_pref_cd THEN
        v_score := 60;

        -- 同じ市区町村なら追加ボーナス
        IF v_job.city_cd = v_user.estimated_city_cd THEN
            v_score := 100;
        END IF;
    ELSE
        v_score := 30;
    END IF;

    -- 座標が利用可能なら距離計算
    IF v_job.latitude IS NOT NULL AND v_user.latitude IS NOT NULL THEN
        v_distance := calculate_distance_km(
            v_user.latitude, v_user.longitude,
            COALESCE(v_job.latitude, v_job.city_lat),
            COALESCE(v_job.longitude, v_job.city_lon)
        );

        v_user_radius := COALESCE(v_user.location_preference_radius, 10);

        -- 距離によるスコア調整
        IF v_distance <= v_user_radius THEN
            v_score := 100;
        ELSIF v_distance <= v_user_radius * 2 THEN
            v_score := 100 - ((v_distance - v_user_radius) / v_user_radius * 50);
        ELSIF v_distance <= v_user_radius * 3 THEN
            v_score := 50 - ((v_distance - v_user_radius * 2) / v_user_radius * 30);
        ELSE
            v_score := GREATEST(0, 20 - (v_distance / 10));
        END IF;
    END IF;

    RETURN v_score;
END;
$$ LANGUAGE plpgsql STABLE;

-- ----------------------------------------------------------------------------
-- 4.4 パーソナライズドスコア統合関数
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_personalized_score(
    p_job_id BIGINT,
    p_user_id INTEGER
) RETURNS FLOAT AS $$
DECLARE
    v_preference_score FLOAT;
    v_collaborative_score FLOAT;
    v_location_score FLOAT;
    v_final_score FLOAT;
BEGIN
    -- 各コンポーネントスコア計算
    v_preference_score := calculate_user_preference_score(p_job_id, p_user_id);
    v_collaborative_score := calculate_collaborative_filtering_score(p_job_id, p_user_id);
    v_location_score := calculate_location_proximity_score(p_job_id, p_user_id);

    -- 重み付け合計
    -- 嗜好: 40%, 協調フィルタリング: 30%, 地域: 30%
    v_final_score := (v_preference_score * 0.4) +
                     (v_collaborative_score * 0.3) +
                     (v_location_score * 0.3);

    RETURN GREATEST(0, LEAST(100, v_final_score));
END;
$$ LANGUAGE plpgsql STABLE;

-- ============================================================================
-- SECTION 5: 総合スコア計算
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 5.1 総合スコア計算（メイン関数）
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION calculate_composite_score(
    p_job_id BIGINT,
    p_user_id INTEGER
) RETURNS FLOAT AS $$
DECLARE
    v_basic_score FLOAT;
    v_seo_score FLOAT;
    v_personalized_score FLOAT;
    v_composite_score FLOAT;
BEGIN
    -- 各スコア計算
    v_basic_score := calculate_basic_score(p_job_id, p_user_id);
    v_seo_score := calculate_seo_score(p_job_id);
    v_personalized_score := calculate_personalized_score(p_job_id, p_user_id);

    -- 重み付け合計（仕様書準拠）
    -- 基礎: 30%, SEO: 20%, パーソナライズ: 50%
    v_composite_score := (v_basic_score * 0.3) +
                        (v_seo_score * 0.2) +
                        (v_personalized_score * 0.5);

    -- user_job_mappingテーブルに結果を保存
    INSERT INTO user_job_mapping (
        user_id, job_id,
        basic_score, seo_score, personalized_score,
        score_components, batch_date
    ) VALUES (
        p_user_id, p_job_id,
        v_basic_score, v_seo_score, v_personalized_score,
        jsonb_build_object(
            'basic', v_basic_score,
            'seo', v_seo_score,
            'personalized', v_personalized_score,
            'composite', v_composite_score
        ),
        CURRENT_DATE
    )
    ON CONFLICT (user_id, job_id, batch_date)
    DO UPDATE SET
        basic_score = EXCLUDED.basic_score,
        seo_score = EXCLUDED.seo_score,
        personalized_score = EXCLUDED.personalized_score,
        score_components = EXCLUDED.score_components;

    RETURN v_composite_score;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- ----------------------------------------------------------------------------
-- 5.2 バッチスコア計算
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION batch_calculate_scores(
    p_user_id INTEGER,
    p_limit INTEGER DEFAULT 1000
) RETURNS TABLE (
    job_id BIGINT,
    composite_score FLOAT,
    basic_score FLOAT,
    seo_score FLOAT,
    personalized_score FLOAT
) AS $$
BEGIN
    RETURN QUERY
    WITH valid_jobs AS (
        SELECT j.job_id
        FROM jobs j
        WHERE j.is_active = TRUE
          AND j.employment_type_cd IN (1, 3)
          AND j.fee > 500
          AND (j.end_at IS NULL OR j.end_at > CURRENT_TIMESTAMP)
          -- 2週間以内の応募企業を除外
          AND NOT EXISTS (
              SELECT 1 FROM user_actions ua
              WHERE ua.user_id = p_user_id
                AND ua.endcl_cd = j.endcl_cd
                AND ua.action_type = 'application'
                AND ua.action_timestamp > CURRENT_DATE - INTERVAL '14 days'
          )
        ORDER BY j.posting_date DESC
        LIMIT p_limit
    )
    SELECT
        vj.job_id,
        calculate_composite_score(vj.job_id, p_user_id) AS composite_score,
        calculate_basic_score(vj.job_id, p_user_id) AS basic_score,
        calculate_seo_score(vj.job_id) AS seo_score,
        calculate_personalized_score(vj.job_id, p_user_id) AS personalized_score
    FROM valid_jobs vj;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- ============================================================================
-- SECTION 6: スコア更新・メンテナンス
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 6.1 求人エンリッチメント更新
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_job_enrichment_scores(
    p_job_id BIGINT
) RETURNS VOID AS $$
DECLARE
    v_basic_score FLOAT;
    v_seo_score FLOAT;
BEGIN
    -- スコア計算
    v_basic_score := calculate_basic_score(p_job_id);
    v_seo_score := calculate_seo_score(p_job_id);

    -- job_enrichmentテーブル更新
    INSERT INTO job_enrichment (
        job_id,
        basic_score,
        seo_score,
        personalized_score_base,
        calculated_at
    ) VALUES (
        p_job_id,
        v_basic_score,
        v_seo_score,
        50.0,  -- ベースライン
        CURRENT_TIMESTAMP
    )
    ON CONFLICT (job_id) DO UPDATE SET
        basic_score = EXCLUDED.basic_score,
        seo_score = EXCLUDED.seo_score,
        calculated_at = EXCLUDED.calculated_at;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- ----------------------------------------------------------------------------
-- 6.2 企業人気度更新
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION update_company_popularity()
RETURNS VOID AS $$
BEGIN
    INSERT INTO company_popularity (
        endcl_cd,
        company_name,
        total_views_360d,
        total_applications_360d,
        unique_applicants_360d,
        last_calculated_at
    )
    SELECT
        j.endcl_cd,
        MAX(j.company_name) AS company_name,
        COUNT(CASE WHEN ua.action_type = 'view' THEN 1 END) AS total_views,
        COUNT(CASE WHEN ua.action_type = 'application' THEN 1 END) AS total_applications,
        COUNT(DISTINCT CASE WHEN ua.action_type = 'application' THEN ua.user_id END) AS unique_applicants,
        CURRENT_TIMESTAMP
    FROM jobs j
    LEFT JOIN user_actions ua ON j.endcl_cd = ua.endcl_cd
        AND ua.action_timestamp > CURRENT_DATE - INTERVAL '360 days'
    GROUP BY j.endcl_cd
    ON CONFLICT (endcl_cd) DO UPDATE SET
        total_views_360d = EXCLUDED.total_views_360d,
        total_applications_360d = EXCLUDED.total_applications_360d,
        unique_applicants_360d = EXCLUDED.unique_applicants_360d,
        last_calculated_at = EXCLUDED.last_calculated_at;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- ============================================================================
-- SECTION 7: バッチ処理用関数
-- ============================================================================

-- ----------------------------------------------------------------------------
-- 7.1 日次スコアリング更新
-- ----------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION daily_scoring_update(
    p_batch_size INTEGER DEFAULT 1000,
    p_max_jobs INTEGER DEFAULT 50000
) RETURNS VOID AS $$
DECLARE
    v_batch_id INTEGER;
    v_processed INTEGER := 0;
    v_job_count INTEGER;
BEGIN
    -- バッチジョブ開始
    INSERT INTO batch_jobs (
        job_type,
        status,
        total_records,
        parameters
    ) VALUES (
        'scoring',
        'running',
        p_max_jobs,
        jsonb_build_object('batch_size', p_batch_size)
    ) RETURNING batch_id INTO v_batch_id;

    -- 企業人気度を先に更新
    PERFORM update_company_popularity();

    -- アクティブな求人をバッチ処理
    FOR v_job_count IN
        SELECT job_id FROM jobs
        WHERE is_active = TRUE
          AND employment_type_cd IN (1, 3)
          AND fee > 500
        ORDER BY posting_date DESC
        LIMIT p_max_jobs
    LOOP
        PERFORM update_job_enrichment_scores(v_job_count);
        v_processed := v_processed + 1;

        -- 進捗更新
        IF v_processed % p_batch_size = 0 THEN
            UPDATE batch_jobs
            SET processed_records = v_processed
            WHERE batch_id = v_batch_id;

            -- CPUを休ませる
            PERFORM pg_sleep(0.1);
        END IF;
    END LOOP;

    -- バッチジョブ完了
    UPDATE batch_jobs
    SET status = 'completed',
        completed_at = CURRENT_TIMESTAMP,
        processed_records = v_processed,
        success_count = v_processed
    WHERE batch_id = v_batch_id;
END;
$$ LANGUAGE plpgsql VOLATILE;

-- ============================================================================
-- 終了メッセージ
-- ============================================================================
-- スコアリング関数作成完了: 20個の関数
-- 3段階スコアリング（基礎・SEO・パーソナライズ）実装完了
-- 次のステップ: 001_master_data.sql でマスターデータを投入