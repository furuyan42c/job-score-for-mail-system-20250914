"""
General Security Vulnerability Tests

一般的なセキュリティ脆弱性テストスイート
- XSS (Cross-Site Scripting) 防止
- CSRF トークン検証
- セキュリティヘッダー (CSP, HSTS, etc.)
- ディレクトリトラバーサル防止
- ファイルアップロードセキュリティ
- レート制限実装
- すべてのエンドポイントの入力検証
"""

import pytest
import pytest_asyncio
from httpx import AsyncClient
from fastapi import status
import time
import asyncio
from unittest.mock import patch, MagicMock
import re
import os
import tempfile
from typing import Dict, List, Any
import xml.etree.ElementTree as ET


class TestXSSPrevention:
    """XSS (Cross-Site Scripting) 防止テスト"""

    @pytest.mark.asyncio
    async def test_reflected_xss_prevention(self, async_client: AsyncClient):
        """反射型XSS防止テスト"""
        xss_payloads = [
            "<script>alert('xss')</script>",
            "<img src=x onerror=alert('xss')>",
            "<svg onload=alert('xss')>",
            "javascript:alert('xss')",
            "<iframe src=javascript:alert('xss')></iframe>",
            "'><script>alert('xss')</script>",
            "\"><script>alert('xss')</script>",
            "<scr<script>ipt>alert('xss')</script>",
            "%3Cscript%3Ealert('xss')%3C/script%3E",
            "&lt;script&gt;alert('xss')&lt;/script&gt;",
        ]

        endpoints_to_test = [
            "/users/?name={}",
            "/jobs/?title={}",
            "/users/?email={}",
            "/jobs/?company={}",
        ]

        for endpoint_template in endpoints_to_test:
            for payload in xss_payloads:
                endpoint = endpoint_template.format(payload)
                response = await async_client.get(endpoint)

                # Check that XSS payload is not reflected in response
                response_text = response.text

                # Should not contain unescaped script tags
                assert "<script>" not in response_text.lower(), f"XSS payload reflected: {payload}"
                assert "javascript:" not in response_text.lower(), f"JavaScript URL reflected: {payload}"
                assert "onerror=" not in response_text.lower(), f"Event handler reflected: {payload}"
                assert "onload=" not in response_text.lower(), f"Event handler reflected: {payload}"

                # Check that payload is properly escaped
                if payload in response_text:
                    # If payload appears, it should be escaped
                    assert "&lt;script&gt;" in response_text or payload not in response_text

    @pytest.mark.asyncio
    async def test_stored_xss_prevention(self, async_client: AsyncClient):
        """格納型XSS防止テスト"""
        xss_payload = "<script>alert('stored_xss')</script>"

        # Try to store XSS payload in user profile
        user_data = {
            "email": "xss_test@example.com",
            "name": xss_payload,
            "age_group": "20代前半",
            "location": "東京都"
        }

        # Create user with malicious data
        response = await async_client.post("/users/", json=user_data)

        if response.status_code == 201:
            user_id = response.json()["id"]

            # Retrieve user data
            response = await async_client.get(f"/users/{user_id}")

            if response.status_code == 200:
                user_data = response.json()
                name = user_data.get("name", "")

                # XSS payload should be escaped or sanitized
                assert "<script>" not in name, "Stored XSS payload not escaped"
                assert "alert(" not in name, "JavaScript code not sanitized"

    @pytest.mark.asyncio
    async def test_dom_xss_prevention(self, async_client: AsyncClient):
        """DOM型XSS防止テスト"""
        # Test client-side XSS prevention (would require frontend testing)
        dom_xss_payloads = [
            "#<script>alert('dom_xss')</script>",
            "#javascript:alert('dom_xss')",
            "#<img src=x onerror=alert('dom_xss')>",
        ]

        # Test that these payloads don't cause issues in API responses
        for payload in dom_xss_payloads:
            response = await async_client.get(f"/users/?search={payload}")

            # Should handle safely
            assert response.status_code in [200, 400, 422]

            if response.status_code == 200:
                # Should not reflect dangerous content
                assert "javascript:" not in response.text.lower()
                assert "<script>" not in response.text.lower()


class TestCSRFProtection:
    """CSRF (Cross-Site Request Forgery) 防止テスト"""

    @pytest.mark.asyncio
    async def test_csrf_token_requirement(self, async_client: AsyncClient):
        """CSRF トークン要件テスト"""
        # Test that state-changing operations require CSRF tokens
        state_changing_endpoints = [
            {"method": "POST", "path": "/users/", "data": {"email": "test@example.com"}},
            {"method": "PUT", "path": "/users/1", "data": {"name": "Updated Name"}},
            {"method": "DELETE", "path": "/users/1"},
            {"method": "POST", "path": "/jobs/", "data": {"title": "Test Job"}},
        ]

        for endpoint in state_changing_endpoints:
            # Make request without CSRF token
            if endpoint["method"] == "POST":
                response = await async_client.post(endpoint["path"], json=endpoint.get("data", {}))
            elif endpoint["method"] == "PUT":
                response = await async_client.put(endpoint["path"], json=endpoint.get("data", {}))
            elif endpoint["method"] == "DELETE":
                response = await async_client.delete(endpoint["path"])

            # Should reject requests without CSRF token (in production)
            # During development, this might be disabled
            if response.status_code == status.HTTP_403_FORBIDDEN:
                assert "csrf" in response.text.lower() or "forbidden" in response.text.lower()

    @pytest.mark.asyncio
    async def test_csrf_token_validation(self, async_client: AsyncClient):
        """CSRF トークン検証テスト"""
        # Get CSRF token
        response = await async_client.get("/csrf-token")

        if response.status_code == 200:
            token_data = response.json()
            csrf_token = token_data.get("csrf_token")

            # Make request with valid CSRF token
            headers = {"X-CSRF-Token": csrf_token}
            response = await async_client.post(
                "/users/",
                json={"email": "csrf_test@example.com", "name": "CSRF Test"},
                headers=headers
            )

            # Should be accepted
            assert response.status_code in [200, 201, 401]  # 401 if auth required

            # Test with invalid CSRF token
            headers = {"X-CSRF-Token": "invalid_token"}
            response = await async_client.post(
                "/users/",
                json={"email": "csrf_test2@example.com", "name": "CSRF Test 2"},
                headers=headers
            )

            # Should be rejected if CSRF is enforced
            if response.status_code == 403:
                assert True  # CSRF protection working
            else:
                # CSRF might be disabled in development
                pass

    @pytest.mark.asyncio
    async def test_same_site_cookie_protection(self, async_client: AsyncClient):
        """SameSite クッキー保護テスト"""
        # Login to get session cookie
        login_data = {"email": "test@example.com", "password": "ValidPassword123!"}
        response = await async_client.post("/auth/login", json=login_data)

        if response.status_code == 200:
            # Check cookie attributes
            set_cookie_headers = response.headers.get_list("set-cookie")

            for cookie_header in set_cookie_headers:
                if "session" in cookie_header.lower():
                    # Should have SameSite attribute
                    assert "SameSite=" in cookie_header, "Session cookie missing SameSite attribute"

                    # Should use Strict or Lax
                    assert any(x in cookie_header for x in ["SameSite=Strict", "SameSite=Lax"]), \
                        "SameSite attribute should be Strict or Lax"

                    # Should be Secure in production
                    if "Secure" in cookie_header:
                        assert True  # Good - Secure flag set


class TestSecurityHeaders:
    """セキュリティヘッダーテスト"""

    @pytest.mark.asyncio
    async def test_content_security_policy(self, async_client: AsyncClient):
        """Content Security Policy テスト"""
        response = await async_client.get("/")

        csp_header = response.headers.get("content-security-policy")
        if csp_header:
            # Should have restrictive CSP
            assert "default-src" in csp_header, "CSP missing default-src directive"

            # Should not allow unsafe-inline or unsafe-eval
            assert "unsafe-inline" not in csp_header, "CSP allows unsafe-inline"
            assert "unsafe-eval" not in csp_header, "CSP allows unsafe-eval"

            # Should be restrictive
            if "'self'" in csp_header:
                assert True  # Good - restricts to same origin
            elif "'none'" in csp_header:
                assert True  # Even better - very restrictive

    @pytest.mark.asyncio
    async def test_x_frame_options(self, async_client: AsyncClient):
        """X-Frame-Options テスト"""
        response = await async_client.get("/")

        x_frame_options = response.headers.get("x-frame-options")
        assert x_frame_options is not None, "Missing X-Frame-Options header"
        assert x_frame_options.upper() in ["DENY", "SAMEORIGIN"], f"Insecure X-Frame-Options: {x_frame_options}"

    @pytest.mark.asyncio
    async def test_x_content_type_options(self, async_client: AsyncClient):
        """X-Content-Type-Options テスト"""
        response = await async_client.get("/")

        x_content_type = response.headers.get("x-content-type-options")
        assert x_content_type is not None, "Missing X-Content-Type-Options header"
        assert x_content_type.lower() == "nosniff", f"Invalid X-Content-Type-Options: {x_content_type}"

    @pytest.mark.asyncio
    async def test_referrer_policy(self, async_client: AsyncClient):
        """Referrer Policy テスト"""
        response = await async_client.get("/")

        referrer_policy = response.headers.get("referrer-policy")
        if referrer_policy:
            secure_policies = [
                "no-referrer",
                "no-referrer-when-downgrade",
                "strict-origin",
                "strict-origin-when-cross-origin"
            ]
            assert any(policy in referrer_policy for policy in secure_policies), \
                f"Insecure referrer policy: {referrer_policy}"

    @pytest.mark.asyncio
    async def test_permissions_policy(self, async_client: AsyncClient):
        """Permissions Policy テスト"""
        response = await async_client.get("/")

        permissions_policy = response.headers.get("permissions-policy")
        if permissions_policy:
            # Should restrict dangerous features
            dangerous_features = ["camera", "microphone", "geolocation", "payment"]

            for feature in dangerous_features:
                if feature in permissions_policy:
                    # Should be restricted
                    assert f"{feature}=()" in permissions_policy, \
                        f"Feature {feature} not properly restricted"


class TestDirectoryTraversal:
    """ディレクトリトラバーサル防止テスト"""

    @pytest.mark.asyncio
    async def test_path_traversal_prevention(self, async_client: AsyncClient):
        """パストラバーサル防止テスト"""
        path_traversal_payloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd",
            "....//....//....//etc/passwd",
            "..%252f..%252f..%252fetc%252fpasswd",
            "../../../etc/shadow",
            "../../windows/win.ini",
            "%2e%2e/%2e%2e/%2e%2e/etc/passwd",
        ]

        # Test file serving endpoints (if any)
        endpoints_to_test = [
            "/files/{}",
            "/uploads/{}",
            "/static/{}",
            "/download/{}",
        ]

        for endpoint_template in endpoints_to_test:
            for payload in path_traversal_payloads:
                endpoint = endpoint_template.format(payload)
                response = await async_client.get(endpoint)

                # Should not allow access to sensitive files
                if response.status_code == 200:
                    content = response.text.lower()

                    # Check that sensitive file contents are not returned
                    sensitive_content = [
                        "root:", "password", "shadow", "sam",
                        "[fonts]", "for 16-bit app", "system.ini"
                    ]

                    for sensitive in sensitive_content:
                        assert sensitive not in content, \
                            f"Directory traversal successful: {payload}"

                # Should return 404, 403, or 400 for invalid paths
                assert response.status_code in [404, 403, 400, 422], \
                    f"Unexpected response for path traversal: {response.status_code}"

    @pytest.mark.asyncio
    async def test_file_inclusion_prevention(self, async_client: AsyncClient):
        """ファイルインクルージョン防止テスト"""
        file_inclusion_payloads = [
            "php://input",
            "php://filter/convert.base64-encode/resource=index.php",
            "data://text/plain;base64,PD9waHAgcGhwaW5mbygpOyA/Pg==",
            "file:///etc/passwd",
            "http://evil.com/shell.txt",
            "ftp://evil.com/shell.txt",
        ]

        # Test template or include parameters (if any)
        for payload in file_inclusion_payloads:
            response = await async_client.get(f"/template?file={payload}")

            # Should not allow file inclusion
            assert response.status_code in [404, 403, 400, 422], \
                f"File inclusion possible: {payload}"

            if response.status_code == 200:
                # Should not contain PHP code or sensitive file content
                content = response.text.lower()
                assert "<?php" not in content, "PHP code inclusion detected"
                assert "root:" not in content, "Sensitive file accessed"


class TestFileUploadSecurity:
    """ファイルアップロードセキュリティテスト"""

    @pytest.mark.asyncio
    async def test_malicious_file_upload_prevention(self, async_client: AsyncClient):
        """悪意のあるファイルアップロード防止テスト"""
        # Create malicious files for testing
        malicious_files = {
            "shell.php": b"<?php system($_GET['cmd']); ?>",
            "shell.jsp": b"<% Runtime.getRuntime().exec(request.getParameter(\"cmd\")); %>",
            "shell.asp": b"<% eval request(\"cmd\") %>",
            "malware.exe": b"\x4d\x5a\x90\x00",  # PE header
            "script.js": b"alert('xss');",
            "malicious.html": b"<script>alert('xss')</script>",
        }

        for filename, content in malicious_files.items():
            with tempfile.NamedTemporaryFile(suffix=f"_{filename}", delete=False) as tmp:
                tmp.write(content)
                tmp.flush()

                try:
                    files = {"file": (filename, content, "application/octet-stream")}
                    response = await async_client.post("/upload", files=files)

                    # Should reject dangerous file types
                    if filename.endswith(('.php', '.jsp', '.asp', '.exe')):
                        assert response.status_code in [400, 403, 415, 422], \
                            f"Dangerous file type accepted: {filename}"

                    # Should not return 500 error (proper validation)
                    assert response.status_code != 500, "Server error on malicious file upload"

                finally:
                    os.unlink(tmp.name)

    @pytest.mark.asyncio
    async def test_file_size_limits(self, async_client: AsyncClient):
        """ファイルサイズ制限テスト"""
        # Create large file
        large_content = b"A" * (10 * 1024 * 1024)  # 10MB

        files = {"file": ("large_file.txt", large_content, "text/plain")}
        response = await async_client.post("/upload", files=files)

        # Should reject files that are too large
        assert response.status_code in [413, 400, 422], "Large file not rejected"

    @pytest.mark.asyncio
    async def test_filename_sanitization(self, async_client: AsyncClient):
        """ファイル名サニタイゼーションテスト"""
        dangerous_filenames = [
            "../../../etc/passwd",
            "shell.php",
            "<script>alert('xss')</script>.txt",
            "file with spaces and special chars!@#$.txt",
            "very_long_filename_" + "a" * 200 + ".txt",
            "file\x00.txt",  # Null byte injection
            "CON.txt",  # Windows reserved name
            "NUL.txt",  # Windows reserved name
        ]

        for dangerous_name in dangerous_filenames:
            files = {"file": (dangerous_name, b"test content", "text/plain")}
            response = await async_client.post("/upload", files=files)

            if response.status_code == 200:
                # If upload succeeds, filename should be sanitized
                response_data = response.json()
                stored_filename = response_data.get("filename", "")

                # Should not contain dangerous characters
                assert "../" not in stored_filename, "Path traversal in filename"
                assert "<script>" not in stored_filename, "XSS in filename"
                assert "\x00" not in stored_filename, "Null byte in filename"

                # Should not use reserved Windows names
                assert stored_filename.upper() not in ["CON.TXT", "NUL.TXT"], \
                    "Reserved filename used"

    @pytest.mark.asyncio
    async def test_file_content_validation(self, async_client: AsyncClient):
        """ファイル内容検証テスト"""
        # Test file with mismatched extension and content
        fake_image = b"<?php echo 'fake image'; ?>"
        files = {"file": ("image.jpg", fake_image, "image/jpeg")}

        response = await async_client.post("/upload", files=files)

        # Should validate file content matches extension
        if response.status_code == 200:
            # File should be properly validated
            # (Real implementation would check magic bytes)
            pass
        else:
            # Rejection is also acceptable for security
            assert response.status_code in [400, 415, 422], "Invalid file content check"


class TestRateLimiting:
    """レート制限テスト"""

    @pytest.mark.asyncio
    async def test_api_rate_limiting(self, async_client: AsyncClient):
        """API レート制限テスト"""
        endpoint = "/users/"
        rate_limit_test_count = 100

        responses = []
        start_time = time.time()

        # Make many requests quickly
        for i in range(rate_limit_test_count):
            response = await async_client.get(endpoint)
            responses.append(response.status_code)

            # If rate limited, should get 429
            if response.status_code == 429:
                break

        end_time = time.time()

        # Should implement rate limiting
        rate_limited_count = sum(1 for status in responses if status == 429)

        if rate_limited_count > 0:
            assert True  # Rate limiting is working
        else:
            # If no rate limiting detected, requests should be processed normally
            successful_requests = sum(1 for status in responses if status == 200)
            assert successful_requests > 0, "No successful requests processed"

    @pytest.mark.asyncio
    async def test_per_user_rate_limiting(self, async_client: AsyncClient):
        """ユーザー別レート制限テスト"""
        # This would require authentication setup
        # Test that each user has individual rate limits

        # Make requests with different user tokens
        users = ["user1@example.com", "user2@example.com"]

        for user_email in users:
            # Get user token (simplified)
            token = await self._get_user_token(async_client, user_email)

            if token:
                headers = {"Authorization": f"Bearer {token}"}

                # Make many requests as this user
                for i in range(50):
                    response = await async_client.get("/users/profile", headers=headers)

                    if response.status_code == 429:
                        # Rate limit reached for this user
                        break

    async def _get_user_token(self, async_client: AsyncClient, email: str):
        """Helper: Get user authentication token"""
        login_data = {"email": email, "password": "ValidPassword123!"}
        response = await async_client.post("/auth/login", json=login_data)

        if response.status_code == 200:
            return response.json().get("access_token")
        return None

    @pytest.mark.asyncio
    async def test_ddos_protection(self, async_client: AsyncClient):
        """DDoS 防御テスト"""
        # Test that the system can handle burst requests
        concurrent_requests = 20

        async def make_request():
            return await async_client.get("/health")

        # Make concurrent requests
        start_time = time.time()
        tasks = [make_request() for _ in range(concurrent_requests)]
        responses = await asyncio.gather(*tasks, return_exceptions=True)
        end_time = time.time()

        # Should handle concurrent requests gracefully
        successful_responses = 0
        rate_limited_responses = 0

        for response in responses:
            if hasattr(response, 'status_code'):
                if response.status_code == 200:
                    successful_responses += 1
                elif response.status_code == 429:
                    rate_limited_responses += 1

        # Should either handle all requests or rate limit some
        assert successful_responses > 0 or rate_limited_responses > 0, \
            "System failed to handle concurrent requests"

        # Response time should be reasonable even under load
        avg_response_time = (end_time - start_time) / concurrent_requests
        assert avg_response_time < 10.0, f"Response time too slow under load: {avg_response_time}s"


class TestInputValidation:
    """入力検証テスト"""

    @pytest.mark.asyncio
    async def test_email_validation(self, async_client: AsyncClient):
        """メールアドレス検証テスト"""
        invalid_emails = [
            "invalid_email",
            "@domain.com",
            "user@",
            "user@domain",
            "user..double@domain.com",
            "user@domain..double.com",
            "user with space@domain.com",
            "user@domain.com.",
            ".user@domain.com",
            "user@-domain.com",
            "user@domain-.com",
        ]

        for email in invalid_emails:
            user_data = {
                "email": email,
                "name": "Test User",
                "age_group": "20代前半"
            }

            response = await async_client.post("/users/", json=user_data)

            # Should reject invalid emails
            assert response.status_code in [400, 422], f"Invalid email accepted: {email}"

    @pytest.mark.asyncio
    async def test_input_length_validation(self, async_client: AsyncClient):
        """入力長検証テスト"""
        # Test various field length limits
        test_cases = [
            {"field": "name", "max_length": 100},
            {"field": "email", "max_length": 254},
            {"field": "location", "max_length": 100},
        ]

        for case in test_cases:
            field = case["field"]
            max_length = case["max_length"]

            # Create data with field too long
            long_value = "A" * (max_length + 1)
            user_data = {
                "email": "test@example.com",
                "name": "Test User",
                "age_group": "20代前半",
                "location": "東京都"
            }
            user_data[field] = long_value

            response = await async_client.post("/users/", json=user_data)

            # Should reject data that's too long
            assert response.status_code in [400, 422], \
                f"Overlong {field} accepted: {len(long_value)} chars"

    @pytest.mark.asyncio
    async def test_special_character_handling(self, async_client: AsyncClient):
        """特殊文字処理テスト"""
        special_chars_data = {
            "email": "test+special@example-domain.com",
            "name": "名前 with スペース & 特殊文字!@#$%",
            "age_group": "20代前半",
            "location": "東京都・渋谷区"
        }

        response = await async_client.post("/users/", json=special_chars_data)

        # Should handle special characters properly
        if response.status_code == 201:
            user_data = response.json()
            # Special characters should be preserved or properly encoded
            assert len(user_data["name"]) > 0, "Name with special chars was empty"

    @pytest.mark.asyncio
    async def test_unicode_input_handling(self, async_client: AsyncClient):
        """Unicode 入力処理テスト"""
        unicode_data = {
            "email": "test@example.com",
            "name": "テスト ユーザー 测试用户 🚀",
            "age_group": "20代前半",
            "location": "東京都"
        }

        response = await async_client.post("/users/", json=unicode_data)

        # Should handle Unicode properly
        if response.status_code == 201:
            user_data = response.json()
            assert "テスト" in user_data["name"], "Unicode characters not preserved"

    @pytest.mark.asyncio
    async def test_null_byte_injection_prevention(self, async_client: AsyncClient):
        """NULL バイトインジェクション防止テスト"""
        null_byte_data = {
            "email": "test\x00@example.com",
            "name": "Test\x00User",
            "age_group": "20代前半",
            "location": "東京都\x00"
        }

        response = await async_client.post("/users/", json=null_byte_data)

        # Should reject or sanitize null bytes
        assert response.status_code in [400, 422, 201], "Null byte handling check"

        if response.status_code == 201:
            user_data = response.json()
            # Null bytes should be removed
            assert "\x00" not in user_data["name"], "Null byte not removed"
            assert "\x00" not in user_data["email"], "Null byte not removed"


if __name__ == "__main__":
    pytest.main([__file__, "-v"])